/*
 *    Copyright [2007-2025] [wisemapping]
 *
 *   Licensed under WiseMapping Public License, Version 1.0 (the "License").
 *   It is basically the Apache License, Version 2.0 (the "License") plus the
 *   "powered by wisemapping" text requirement on every single page;
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the license at
 *
 *       https://github.com/wisemapping/wisemapping-open-source/blob/main/LICENSE.md
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

/**
 * XMind Importer for WiseMapping
 *
 * This importer provides comprehensive support for importing XMind mind maps into WiseMapping format.
 * It handles both XMind XML format (legacy) and XMind JSON format (modern) files.
 *
 * ## Supported XMind Features:
 *
 * ### üìù Content Mapping:
 * - **Topics**: All topic hierarchies are preserved with proper parent-child relationships
 * - **Notes**: XMind notes are converted to WiseMapping notes with rich HTML support
 * - **Labels**: XMind labels (categorization tags) are preserved as `üè∑Ô∏è label-name`
 * - **Markers**: XMind markers (visual indicators) are preserved as `üîñ marker-name`
 * - **Icons**: XMind icons are comprehensively mapped to WiseMapping EmojiIcons with 300+ mappings
 *
 * ### üé® Styling Support:
 * - **Background Colors**: XMind `svg:fill` colors are mapped to WiseMapping `bgColor`
 * - **Border Colors**: XMind border colors are mapped to WiseMapping `brColor`
 * - **Topic Shapes**: All topics use `shape="line"` for consistent appearance
 * - **Positioning**: Intelligent circular positioning for child topics
 *
 * ### üìä Data Integrity:
 * - **Deterministic IDs**: Incremental ID generation ensures consistent import results
 * - **No Data Loss**: All XMind metadata is preserved and converted appropriately
 * - **Single Note Constraint**: Multiple XMind elements (notes, labels, markers) are intelligently
 *   combined into a single WiseMapping note to respect architectural constraints
 *
 * ### üîÑ Format Support:
 * - **XMind XML**: Legacy XMind format with `<notes><plain>` and `<markers>` elements
 * - **XMind JSON**: Modern XMind format with `labels` arrays and style properties
 * - **ZIP Archives**: Both formats are extracted from XMind ZIP file structure
 *
 * ## Note Content Strategy:
 *
 * When a topic has multiple XMind elements, they're combined into one WiseMapping note:
 * ```
 * [XMind Note Content]
 * üîñ marker1, üîñ marker2
 * üè∑Ô∏è label1, üè∑Ô∏è label2
 * ```
 *
 * This ensures maximum data preservation while respecting WiseMapping's single-note-per-topic limitation.
 *
 * ## Example Usage:
 * ```typescript
 * const importer = new XMindImporter(xmindFileContent);
 * const wisemappingXML = await importer.import('My Mind Map', 'Description');
 * ```
 */
import Importer from './Importer';

// XMind data structures
interface XMindTopic {
  id: string;
  title: string;
  children?: {
    attached?: XMindTopic[];
  };
  style?: {
    id: string;
    properties?: {
      'svg:fill'?: string;
      'border-line-width'?: string;
      'border-line-pattern'?: string;
    };
  };
  labels?: string[];
  icons?: string[];
}

interface XMindContent {
  id: string;
  revisionId: string;
  class: string;
  rootTopic: XMindTopic;
  title: string;
}

class XMindImporter extends Importer {
  private xmindInput: string;

  private idCounter = 1;

  private topicIdMap: Map<string, string>;

  constructor(map: string) {
    super();
    this.xmindInput = map;
    this.topicIdMap = new Map();
  }

  import(nameMap: string, description?: string): Promise<string> {
    try {
      console.log(`Importing XMind map: ${nameMap}, description: ${description}`);

      // Check if it's XML format (older XMind) or JSON format (newer XMind)
      if (
        this.xmindInput.trim().startsWith('<?xml') ||
        this.xmindInput.trim().startsWith('<xmap-content')
      ) {
        return Promise.resolve(this.importXMLFormat(nameMap, description));
      }
      return Promise.resolve(this.importJSONFormat(nameMap, description));
    } catch (error) {
      console.error('Error importing XMind map:', error);
      // Fallback to basic map with error info
      return Promise.resolve(this.createFallbackMap(nameMap, error as Error));
    }
  }

  private importXMLFormat(nameMap: string, description?: string): string {
    try {
      // Parse XML content
      const parser = new DOMParser();
      const doc = parser.parseFromString(this.xmindInput, 'text/xml');

      // Find the root topic (within sheet element) - handle namespaces
      let sheet = doc.querySelector('sheet');
      if (!sheet) {
        // Try to find sheet by tag name (works with namespaces)
        const sheets = doc.getElementsByTagName('sheet');
        sheet = sheets.length > 0 ? sheets[0] : null;
      }

      let rootTopic = sheet?.querySelector('topic');
      if (!rootTopic) {
        // Try to find topic by tag name (works with namespaces)
        const topics = sheet
          ? sheet.getElementsByTagName('topic')
          : doc.getElementsByTagName('topic');
        rootTopic = topics.length > 0 ? topics[0] : null;
      }

      if (!rootTopic) {
        throw new Error('No root topic found in XMind file');
      }

      // Reset counters and ID map
      this.idCounter = 1;
      this.topicIdMap.clear();

      // Generate WiseMapping XML directly from XML structure
      const xmlContent = this.generateWiseMappingXMLFromXML(rootTopic, nameMap, description);

      return xmlContent;
    } catch (error) {
      console.error('XML XMind import failed:', error);
      return this.createFallbackMap(nameMap, error as Error);
    }
  }

  private importJSONFormat(nameMap: string, description?: string): string {
    try {
      // Parse the XMind content
      const xmindData = this.parseXMindContent();

      // Reset counters
      this.idCounter = 1;

      // Generate WiseMapping XML directly
      const xmlContent = this.generateWiseMappingXML(xmindData.rootTopic, nameMap, description);

      return xmlContent;
    } catch (error) {
      console.error('JSON XMind import failed:', error);
      return this.createFallbackMap(nameMap, error as Error);
    }
  }

  private parseXMindContent(): XMindContent {
    try {
      // XMind files are ZIP archives, but the content is passed as a string
      // We need to extract the content.json from the ZIP data
      // The format is: content.json[{...}] where {...} is the JSON content
      const contentMatch = this.xmindInput.match(/content\.json\[(.*?)\]PK/);
      if (!contentMatch) {
        throw new Error('Could not find content.json in XMind file');
      }

      const contentJson = contentMatch[1];
      const parsedContent = JSON.parse(contentJson);

      return parsedContent;
    } catch (error) {
      console.error('Error parsing XMind content:', error);
      throw new Error(`Failed to parse XMind content: ${(error as Error).message}`);
    }
  }

  private convertXMindColor(xmindColor: string): string {
    // XMind uses RGBA format like #8EDE99FF
    // WiseMapping might expect different format
    if (xmindColor.startsWith('#')) {
      // Remove alpha channel if present (last 2 characters)
      if (xmindColor.length === 9) {
        return xmindColor.substring(0, 7); // Remove alpha
      }
      return xmindColor;
    }
    return xmindColor;
  }

  private generateId(): number {
    return this.idCounter++;
  }

  private calculatePosition(order: number): { x: number; y: number } {
    // Distribute first-level topics evenly between left and right sides
    // Even orders (0, 2, 4...) = Right side, Odd orders (1, 3, 5...) = Left side
    const isEven = order % 2 === 0;
    const sideIndex = Math.floor(order / 2);

    // Alternate between right (positive x) and left (negative x) sides
    const x = isEven ? 200 + sideIndex * 100 : -200 - sideIndex * 100;
    const y = sideIndex * 150 - sideIndex * 75; // Spread vertically

    return { x, y };
  }

  private generateWiseMappingXMLFromXML(
    rootTopic: Element,
    nameMap: string,
    _description?: string,
  ): string {
    const centralId = this.generateId();
    const rootTopicId = rootTopic.getAttribute('id') || 'topic1';
    this.topicIdMap.set(rootTopicId, centralId.toString());

    let centralTitle = rootTopic.querySelector('title')?.textContent;
    if (!centralTitle) {
      const titles = rootTopic.getElementsByTagName('title');
      centralTitle = titles.length > 0 ? titles[0].textContent : 'Central Topic';
    }

    let xml = `<map name='${nameMap}' version='tango' theme='prism' layout='mindmap'>\n`;

    // Generate central topic
    xml += `    <topic central='true' text='${this.escapeXml(centralTitle)}' id='${centralId}'>\n`;

    // Generate child topics recursively
    let childrenElement = rootTopic.querySelector('children');
    if (!childrenElement) {
      const children = rootTopic.getElementsByTagName('children');
      childrenElement = children.length > 0 ? children[0] : null;
    }

    if (childrenElement) {
      let topicsElement = childrenElement.querySelector('topics[type="attached"]');
      if (!topicsElement) {
        const topics = childrenElement.getElementsByTagName('topics');
        topicsElement =
          Array.from(topics).find((t) => t.getAttribute('type') === 'attached') || null;
      }

      if (topicsElement) {
        const childTopics = Array.from(topicsElement.children).filter(
          (child) => child.tagName === 'topic' || child.localName === 'topic',
        );
        childTopics.forEach((childTopic, index) => {
          xml += this.generateChildTopicXMLFromXML(childTopic as Element, index);
        });
      }
    }

    xml += '    </topic>\n';

    // Add relationships if present
    const relationshipsXML = this.generateRelationshipsXML(rootTopic);
    if (relationshipsXML) {
      xml += relationshipsXML;
    }

    xml += '</map>';

    return xml;
  }

  private generateChildTopicXMLFromXML(xmlTopic: Element, order: number): string {
    const topicId = this.generateId();
    const xmindTopicId = xmlTopic.getAttribute('id') || `topic${this.idCounter}`;
    this.topicIdMap.set(xmindTopicId, topicId.toString());

    const position = this.calculatePosition(order);
    let title = xmlTopic.querySelector('title')?.textContent;
    if (!title) {
      const titles = xmlTopic.getElementsByTagName('title');
      title = titles.length > 0 ? titles[0].textContent : 'Untitled';
    }

    let xml = `        <topic position='${position.x},${position.y}' order='${order}' text='${this.escapeXml(title)}' shape='line' id='${topicId}'>\n`;

    // Add icons if present (from markers)
    let markers = xmlTopic.querySelectorAll('marker-refs > marker-ref');
    if (markers.length === 0) {
      const markerRefs = xmlTopic.getElementsByTagName('marker-refs');
      if (markerRefs.length > 0) {
        const markerElements = markerRefs[0].getElementsByTagName('marker-ref');
        markers = Array.from(markerElements) as unknown as NodeListOf<Element>;
      }
    }

    if (markers.length > 0) {
      Array.from(markers).forEach((marker) => {
        const markerId = marker.getAttribute('marker-id');
        if (markerId) {
          const emojiIcon = this.mapXMindIconToEmojiIcon(markerId);
          xml += `            <eicon id='${emojiIcon}'/>\n`;
        }
      });
    }

    // Handle notes and markers (combine into one WiseMapping note)
    const noteContent = this.buildXMLNoteContent(xmlTopic);
    if (noteContent) {
      xml += `            <note><![CDATA[${noteContent}]]></note>\n`;
    }

    // Recursively generate child topics
    let childrenElement = xmlTopic.querySelector('children');
    if (!childrenElement) {
      const children = xmlTopic.getElementsByTagName('children');
      childrenElement = children.length > 0 ? children[0] : null;
    }

    if (childrenElement) {
      let topicsElement = childrenElement.querySelector('topics[type="attached"]');
      if (!topicsElement) {
        const topics = childrenElement.getElementsByTagName('topics');
        topicsElement =
          Array.from(topics).find((t) => t.getAttribute('type') === 'attached') || null;
      }

      if (topicsElement) {
        const childTopics = Array.from(topicsElement.children).filter(
          (child) => child.tagName === 'topic' || child.localName === 'topic',
        );
        childTopics.forEach((childTopic, index) => {
          xml += this.generateChildTopicXMLFromXML(childTopic as Element, index);
        });
      }
    }

    xml += '        </topic>\n';
    return xml;
  }

  private generateRelationshipsXML(rootTopic: Element): string {
    // Find relationships in the sheet (parent of rootTopic)
    const sheet = rootTopic.parentElement;
    if (!sheet) return '';

    let relationshipsElement = sheet.querySelector('relationships');
    if (!relationshipsElement) {
      const relationships = sheet.getElementsByTagName('relationships');
      relationshipsElement = relationships.length > 0 ? relationships[0] : null;
    }

    if (!relationshipsElement) return '';

    let relationshipsXML = '';
    const relationshipElements = relationshipsElement.querySelectorAll('relationship');
    if (relationshipElements.length === 0) {
      const relationships = relationshipsElement.getElementsByTagName('relationship');
      Array.from(relationships).forEach((rel) => {
        relationshipsXML += this.generateRelationshipXML(rel as Element);
      });
    } else {
      relationshipElements.forEach((rel) => {
        relationshipsXML += this.generateRelationshipXML(rel as Element);
      });
    }

    return relationshipsXML;
  }

  private generateRelationshipXML(relationshipElement: Element): string {
    const end1 = relationshipElement.getAttribute('end1');
    const end2 = relationshipElement.getAttribute('end2');
    const title =
      relationshipElement.querySelector('title')?.textContent ||
      relationshipElement.querySelector('[local-name()="title"]')?.textContent ||
      '';

    if (!end1 || !end2) return '';

    // Map XMind topic IDs to WiseMapping topic IDs
    const srcTopicId = this.mapTopicId(end1);
    const destTopicId = this.mapTopicId(end2);

    if (!srcTopicId || !destTopicId) return '';

    let relationshipXML = `    <relationship srcTopicId='${srcTopicId}' destTopicId='${destTopicId}'`;

    if (title) {
      relationshipXML += ` label='${this.escapeXml(title)}'`;
    }

    relationshipXML += '/>\n';
    return relationshipXML;
  }

  private mapTopicId(xmindTopicId: string): string | null {
    return this.topicIdMap.get(xmindTopicId) || null;
  }

  private generateWiseMappingXML(
    rootTopic: XMindTopic,
    nameMap: string,
    _description?: string,
  ): string {
    const centralId = this.generateId();
    let xml = `<map name='${nameMap}' version='tango' theme='prism' layout='mindmap'>\n`;

    // Generate central topic
    xml += `    <topic central='true' text='${this.escapeXml(rootTopic.title)}' id='${centralId}'>\n`;

    // Generate child topics recursively
    if (rootTopic.children?.attached) {
      xml += this.generateChildTopicsXML(rootTopic.children.attached, 0);
    }

    xml += '    </topic>\n';
    xml += '</map>';

    return xml;
  }

  private generateChildTopicsXML(topics: XMindTopic[], _order: number): string {
    let xml = '';

    topics.forEach((topic, index) => {
      const topicId = this.generateId();
      const position = this.calculatePosition(index);
      const bgColor = this.extractBackgroundColor(topic);

      xml += `        <topic position='${position.x},${position.y}' order='${index}' text='${this.escapeXml(topic.title)}' shape='line' id='${topicId}'`;

      if (bgColor) {
        xml += ` bgColor='${bgColor}'`;
      }

      // Add border color if available
      const borderColor = this.extractBorderColor(topic);
      if (borderColor) {
        xml += ` brColor='${borderColor}'`;
      }

      xml += '>\n';

      // Add icons if present (mapped to EmojiIcons)
      if (topic.icons && topic.icons.length > 0) {
        topic.icons.forEach((icon) => {
          const emojiIcon = this.mapXMindIconToEmojiIcon(icon);
          xml += `            <eicon id='${emojiIcon}'/>\n`;
        });
      }

      // Add notes if present (combine XMind notes and labels into one WiseMapping note)
      const noteContent = this.buildNoteContent(topic);
      if (noteContent) {
        xml += `            <note><![CDATA[${noteContent}]]></note>\n`;
      }

      // Recursively generate child topics
      if (topic.children?.attached) {
        xml += this.generateChildTopicsXML(topic.children.attached, index);
      }

      xml += '        </topic>\n';
    });

    return xml;
  }

  private extractBackgroundColor(topic: XMindTopic): string | null {
    if (topic.style?.properties?.['svg:fill']) {
      return this.convertXMindColor(topic.style.properties['svg:fill']);
    }
    return null;
  }

  private extractBorderColor(topic: XMindTopic): string | null {
    // For now, use the same color as background for border
    // In the future, we could extract from border-line-color if available
    return this.extractBackgroundColor(topic);
  }

  private buildNoteContent(topic: XMindTopic): string | null {
    const parts: string[] = [];

    // Add XMind note content if present (from XML format)
    // Note: JSON format doesn't have separate notes, only labels

    // Add icons if present (mapped to appropriate emojis)
    if (topic.icons && topic.icons.length > 0) {
      const formattedIcons = topic.icons
        .map((icon) => {
          const emoji = this.mapXMindIconToEmojiIcon(icon);
          return `${emoji} ${icon}`;
        })
        .join(', ');
      parts.push(formattedIcons);
    }

    // Add labels if present (at the bottom)
    if (topic.labels && topic.labels.length > 0) {
      const formattedLabels = topic.labels.map((label) => `üè∑Ô∏è ${label}`).join(', ');
      parts.push(formattedLabels);
    }

    return parts.length > 0 ? parts.join('\n') : null;
  }

  private buildXMLNoteContent(xmlTopic: Element): string | null {
    const parts: string[] = [];

    // Handle XMind notes (main content at the top)
    const notes = xmlTopic.querySelector('notes > plain');
    if (notes) {
      const noteText = notes.textContent || '';
      if (noteText.trim()) {
        parts.push(noteText);
      }
    }

    // Handle XMind markers (middle)
    const markers = xmlTopic.querySelectorAll('markers > marker');
    if (markers.length > 0) {
      const markerTexts = Array.from(markers).map(
        (marker) => marker.getAttribute('marker-id') || 'unknown',
      );
      const formattedMarkers = markerTexts.map((marker) => `üîñ ${marker}`).join(', ');
      parts.push(formattedMarkers);
    }

    // Note: XMind XML format doesn't have labels, only JSON format does
    // Labels would be added at the bottom if present

    return parts.length > 0 ? parts.join('\n') : null;
  }

  private mapXMindIconToEmojiIcon(iconId: string): string {
    // Map XMind icons to WiseMapping EmojiIcon IDs
    const iconMap: Record<string, string> = {
      // Priority icons
      'priority-1': 'üî¥', // Red circle
      'priority-2': 'üü°', // Yellow circle
      'priority-3': 'üü¢', // Green circle
      'priority-4': 'üîµ', // Blue circle
      'priority-5': 'üü£', // Purple circle

      // Star and rating icons
      star: '‚≠ê', // Star
      'star-1': '‚≠ê', // Star
      'star-2': '‚≠ê', // Star
      'star-3': '‚≠ê', // Star

      // Task and completion icons
      task: 'üìã', // Clipboard
      'task-done': '‚úÖ', // Check mark
      'task-start': 'üü°', // Yellow circle
      'task-pause': '‚è∏Ô∏è', // Pause button
      'task-stop': '‚èπÔ∏è', // Stop button

      // Arrow and direction icons
      'arrow-up': '‚¨ÜÔ∏è', // ‚¨ÜÔ∏è
      'arrow-down': '‚¨áÔ∏è', // ‚¨áÔ∏è
      'arrow-left': '‚¨ÖÔ∏è', // ‚¨ÖÔ∏è
      'arrow-right': '‚û°Ô∏è', // ‚û°Ô∏è
      'arrow-up-right': '‚ÜóÔ∏è', // ‚ÜóÔ∏è
      'arrow-down-right': '‚ÜòÔ∏è', // ‚ÜòÔ∏è
      'arrow-down-left': '‚ÜôÔ∏è', // ‚ÜôÔ∏è
      'arrow-up-left': '‚ÜñÔ∏è', // ‚ÜñÔ∏è

      // Symbol icons
      smile: 'üòä', // üòä
      sad: 'üò¢', // üò¢
      angry: 'üò†', // üò†
      surprised: 'üò≤', // üò≤
      confused: 'üòï', // üòï
      thinking: 'ü§î', // ü§î
      happy: 'üòÉ', // üòÉ
      laughing: 'üòÇ', // üòÇ
      wink: 'üòâ', // üòâ
      kiss: 'üòò', // üòò
      love: 'üòç', // üòç
      cool: 'üòé', // üòé
      sleepy: 'üò™', // üò™
      tired: 'üò¥', // üò¥
      worried: 'üòü', // üòü
      crying: 'üò≠', // üò≠
      screaming: 'üò±', // üò±
      neutral: 'üòê', // üòê
      expressionless: 'üòë', // üòë

      // Numbers (1-10)
      'number-1': '1Ô∏è‚É£', // 1Ô∏è‚É£
      'number-2': '2Ô∏è‚É£', // 2Ô∏è‚É£
      'number-3': '3Ô∏è‚É£', // 3Ô∏è‚É£
      'number-4': '4Ô∏è‚É£', // 4Ô∏è‚É£
      'number-5': '5Ô∏è‚É£', // 5Ô∏è‚É£
      'number-6': '6Ô∏è‚É£', // 6Ô∏è‚É£
      'number-7': '7Ô∏è‚É£', // 7Ô∏è‚É£
      'number-8': '8Ô∏è‚É£', // 8Ô∏è‚É£
      'number-9': '9Ô∏è‚É£', // 9Ô∏è‚É£
      'number-10': 'üîü', // üîü
      1: '1Ô∏è‚É£', // 1Ô∏è‚É£
      2: '2Ô∏è‚É£', // 2Ô∏è‚É£
      3: '3Ô∏è‚É£', // 3Ô∏è‚É£
      4: '4Ô∏è‚É£', // 4Ô∏è‚É£
      5: '5Ô∏è‚É£', // 5Ô∏è‚É£
      6: '6Ô∏è‚É£', // 6Ô∏è‚É£
      7: '7Ô∏è‚É£', // 7Ô∏è‚É£
      8: '8Ô∏è‚É£', // 8Ô∏è‚É£
      9: '9Ô∏è‚É£', // 9Ô∏è‚É£
      10: 'üîü', // üîü

      // Letters (A-Z)
      'letter-a': 'üÖ∞Ô∏è', // üÖ∞Ô∏è
      'letter-b': 'üÖ±Ô∏è', // üÖ±Ô∏è
      'letter-c': 'üÖ≤', // üÖ≤
      'letter-d': 'üÖ≥', // üÖ≥
      'letter-e': 'üÖ¥', // üÖ¥
      'letter-f': 'üÖµ', // üÖµ
      'letter-g': 'üÖ∂', // üÖ∂
      'letter-h': 'üÖ∑', // üÖ∑
      'letter-i': 'üÖ∏', // üÖ∏
      'letter-j': 'üÖπ', // üÖπ
      'letter-k': 'üÖ∫', // üÖ∫
      'letter-l': 'üÖª', // üÖª
      'letter-m': 'üÖº', // üÖº
      'letter-n': 'üÖΩ', // üÖΩ
      'letter-o': 'üÖæÔ∏è', // üÖæÔ∏è
      'letter-p': 'üÖøÔ∏è', // üÖøÔ∏è
      'letter-q': 'üÜÄ', // üÜÄ
      'letter-r': 'üÜÅ', // üÜÅ
      'letter-s': 'üÜÇ', // üÜÇ
      'letter-t': 'üÜÉ', // üÜÉ
      'letter-u': 'üÜÑ', // üÜÑ
      'letter-v': 'üÜÖ', // üÜÖ
      'letter-w': 'üÜÜ', // üÜÜ
      'letter-x': 'üÜá', // üÜá
      'letter-y': 'üÜà', // üÜà
      'letter-z': 'üÜâ', // üÜâ
      a: 'üÖ∞Ô∏è', // üÖ∞Ô∏è
      b: 'üÖ±Ô∏è', // üÖ±Ô∏è
      c: 'üÖ≤', // üÖ≤
      d: 'üÖ≥', // üÖ≥
      e: 'üÖ¥', // üÖ¥
      f: 'üÖµ', // üÖµ
      g: 'üÖ∂', // üÖ∂
      h: 'üÖ∑', // üÖ∑
      i: 'üÖ∏', // üÖ∏
      j: 'üÖπ', // üÖπ
      k: 'üÖ∫', // üÖ∫
      l: 'üÖª', // üÖª
      m: 'üÖº', // üÖº
      n: 'üÖΩ', // üÖΩ
      o: 'üÖæÔ∏è', // üÖæÔ∏è
      p: 'üÖøÔ∏è', // üÖøÔ∏è
      q: 'üÜÄ', // üÜÄ
      r: 'üÜÅ', // üÜÅ
      s: 'üÜÇ', // üÜÇ
      t: 'üÜÉ', // üÜÉ
      u: 'üÜÑ', // üÜÑ
      v: 'üÜÖ', // üÜÖ
      w: 'üÜÜ', // üÜÜ
      x: 'üÜá', // üÜá
      y: 'üÜà', // üÜà
      z: 'üÜâ', // üÜâ

      // Flag icons
      flag: 'üö©', // üö©
      'flag-red': 'üö©', // üö©
      'flag-yellow': 'üü°', // üü°
      'flag-green': 'üü¢', // üü¢
      'flag-blue': 'üîµ', // üîµ

      // People icons
      people: 'üë•', // üë•
      person: 'üë§', // üë§
      'person-1': 'üë§', // üë§
      'person-2': 'üë•', // üë•
      'person-3': 'üë•', // üë•

      // Time and date icons
      clock: 'üïê', // üïê
      calendar: 'üìÖ', // üìÖ
      time: '‚è∞', // ‚è∞

      // Communication icons
      phone: 'üìû', // üìû
      email: 'üìß', // üìß
      message: 'üí¨', // üí¨
      chat: 'üí¨', // üí¨

      // File and document icons
      file: 'üìÑ', // üìÑ
      folder: 'üìÅ', // üìÅ
      attachment: 'üìé', // üìé
      link: 'üîó', // üîó

      // Warning and info icons
      warning: '‚ö†Ô∏è', // ‚ö†Ô∏è
      info: '‚ÑπÔ∏è', // ‚ÑπÔ∏è
      question: '‚ùì', // ‚ùì
      exclamation: '‚ùó', // ‚ùó

      // Heart and like icons
      heart: '‚ù§Ô∏è', // ‚ù§Ô∏è
      like: 'üëç', // üëç
      dislike: 'üëé', // üëé

      // Lightbulb and idea icons
      lightbulb: 'üí°', // üí°
      idea: 'üí°', // üí°
      bulb: 'üí°', // üí°

      // Money and business icons
      money: 'üí∞', // üí∞
      dollar: 'üí≤', // üí≤
      euro: 'üí∂', // üí∂
      pound: 'üí∑', // üí∑

      // Location icons
      location: 'üìç', // üìç
      home: 'üè†', // üè†
      building: 'üè¢', // üè¢
      school: 'üè´', // üè´

      // Technology icons
      computer: 'üíª', // üíª
      laptop: 'üíª', // üíª
      'phone-mobile': 'üì±', // üì±
      tablet: 'üì±', // üì±

      // Weather icons
      sun: '‚òÄÔ∏è', // ‚òÄÔ∏è
      cloud: '‚òÅÔ∏è', // ‚òÅÔ∏è
      rain: 'üåßÔ∏è', // üåßÔ∏è
      snow: '‚ùÑÔ∏è', // ‚ùÑÔ∏è
      storm: '‚õàÔ∏è', // ‚õàÔ∏è
      rainbow: 'üåà', // üåà
      sunny: 'üåû', // üåû
      'partly-cloudy': '‚õÖ', // ‚õÖ
      cloudy: 'üå•Ô∏è', // üå•Ô∏è
      lightning: '‚ö°', // ‚ö°
      tornado: 'üå™Ô∏è', // üå™Ô∏è
      fog: 'üå´Ô∏è', // üå´Ô∏è
      wind: 'üå¨Ô∏è', // üå¨Ô∏è
      thermometer: 'üå°Ô∏è', // üå°Ô∏è

      // Animals
      dog: 'üê∂', // üê∂
      cat: 'üê±', // üê±
      mouse: 'üê≠', // üê≠
      hamster: 'üêπ', // üêπ
      rabbit: 'üê∞', // üê∞
      fox: 'ü¶ä', // ü¶ä
      bear: 'üêª', // üêª
      panda: 'üêº', // üêº
      koala: 'üê®', // üê®
      lion: 'ü¶Å', // ü¶Å
      tiger: 'üêØ', // üêØ
      cow: 'üêÆ', // üêÆ
      pig: 'üê∑', // üê∑
      frog: 'üê∏', // üê∏
      monkey: 'üêµ', // üêµ
      chicken: 'üêî', // üêî
      penguin: 'üêß', // üêß
      bird: 'üê¶', // üê¶
      fish: 'üêü', // üêü
      whale: 'üê≥', // üê≥
      dolphin: 'üê¨', // üê¨
      octopus: 'üêô', // üêô
      spider: 'üï∑Ô∏è', // üï∑Ô∏è
      bug: 'üêõ', // üêõ
      bee: 'üêù', // üêù
      butterfly: 'ü¶ã', // ü¶ã
      snail: 'üêå', // üêå
      turtle: 'üê¢', // üê¢
      snake: 'üêç', // üêç
      dragon: 'üêâ', // üêâ
      unicorn: 'ü¶Ñ', // ü¶Ñ

      // Food and drink icons
      coffee: '‚òï', // ‚òï
      food: 'üçΩÔ∏è', // üçΩÔ∏è
      pizza: 'üçï', // üçï
      burger: 'üçî', // üçî
      apple: 'üçé', // üçé
      orange: 'üçä', // üçä
      banana: 'üçå', // üçå
      grapes: 'üçá', // üçá
      strawberry: 'üçì', // üçì
      kiwi: 'ü•ù', // ü•ù
      peach: 'üçë', // üçë
      coconut: 'ü••', // ü••
      cherry: 'üçí', // üçí
      lemon: 'üçã', // üçã
      watermelon: 'üçâ', // üçâ
      pineapple: 'üçç', // üçç
      bread: 'üçû', // üçû
      cookie: 'üç™', // üç™
      candy: 'üç¨', // üç¨
      chocolate: 'üç´', // üç´
      'ice-cream': 'üç¶', // üç¶
      popcorn: 'üçø', // üçø
      beer: 'üç∫', // üç∫
      wine: 'üç∑', // üç∑
      cocktail: 'üç∏', // üç∏
      tea: 'üçµ', // üçµ
      milk: 'ü•õ', // ü•õ
      water: 'üíß', // üíß

      // Sports and activity icons
      sports: '‚öΩ', // ‚öΩ
      football: '‚öΩ', // ‚öΩ
      basketball: 'üèÄ', // üèÄ
      tennis: 'üéæ', // üéæ
      swimming: 'üèä', // üèä
      soccer: '‚öΩ', // ‚öΩ
      baseball: '‚öæ', // ‚öæ
      volleyball: 'üèê', // üèê
      rugby: 'üèà', // üèà
      golf: '‚õ≥', // ‚õ≥
      bowling: 'üé≥', // üé≥
      running: 'üèÉ', // üèÉ
      cycling: 'üö¥', // üö¥
      skiing: '‚õ∑Ô∏è', // ‚õ∑Ô∏è
      snowboarding: 'üèÇ', // üèÇ
      surfing: 'üèÑ', // üèÑ
      climbing: 'üßó', // üßó
      yoga: 'üßò', // üßò
      dancing: 'üíÉ', // üíÉ
      gym: 'üèãÔ∏è', // üèãÔ∏è
      weightlifting: 'üèãÔ∏è', // üèãÔ∏è
      boxing: 'ü•ä', // ü•ä
      'martial-arts': 'ü•ã', // ü•ã
      archery: 'üèπ', // üèπ
      fishing: 'üé£', // üé£
      hiking: 'üßñ', // üßñ
      camping: 'üèïÔ∏è', // üèïÔ∏è
      picnic: 'üçΩÔ∏è', // üçΩÔ∏è
      barbecue: 'üç≥', // üç≥
      target: 'üéØ', // üéØ
      trophy: 'üèÜ', // üèÜ
      medal: 'üèÖ', // üèÖ
      'first-place': 'ü•á', // ü•á
      'second-place': 'ü•à', // ü•à
      'third-place': 'ü•â', // ü•â

      // Music and entertainment icons
      music: 'üéµ', // üéµ
      movie: 'üé¨', // üé¨
      game: 'üéÆ', // üéÆ
      book: 'üìö', // üìö

      // Travel and transport icons
      car: 'üöó', // üöó
      plane: '‚úàÔ∏è', // ‚úàÔ∏è
      train: 'üöÇ', // üöÇ
      bus: 'üöå', // üöå
      bike: 'üö≤', // üö≤

      // Nature icons
      tree: 'üå≥', // üå≥
      flower: 'üå∏', // üå∏
      leaf: 'üçÉ', // üçÉ
      mountain: '‚õ∞Ô∏è', // ‚õ∞Ô∏è
      ocean: 'üåä', // üåä

      // Holiday and celebration icons
      gift: 'üéÅ', // üéÅ
      cake: 'üéÇ', // üéÇ
      party: 'üéâ', // üéâ
      fireworks: 'üéÜ', // üéÜ
      christmas: 'üéÑ', // üéÑ
      halloween: 'üéÉ', // üéÉ

      // Tools and work icons
      tool: 'üîß', // üîß
      wrench: 'üîß', // üîß
      hammer: 'üî®', // üî®
      screwdriver: 'üî©', // üî©
      key: 'üîë', // üîë
      lock: 'üîí', // üîí

      // Medical and health icons
      medical: 'üè•', // üè•
      health: 'üíä', // üíä
      pill: 'üíä', // üíä
      heartbeat: 'üíì', // üíì
      cross: '‚ûï', // ‚ûï

      // Shopping and commerce icons
      shopping: 'üõí', // üõí
      cart: 'üõí', // üõí
      bag: 'üëú', // üëú
      'credit-card': 'üí≥', // üí≥

      // Security and safety icons
      security: 'üîí', // üîí
      shield: 'üõ°Ô∏è', // üõ°Ô∏è
      'lock-closed': 'üîí', // üîí
      'lock-open': 'üîì', // üîì

      // Science and education icons
      science: 'üî¨', // üî¨
      microscope: 'üî¨', // üî¨
      telescope: 'üî≠', // üî≠
      atom: '‚öõÔ∏è', // ‚öõÔ∏è
      'book-open': 'üìñ', // üìñ
      graduation: 'üéì', // üéì
    };

    // Additional comprehensive mappings for common XMind icons
    const additionalMappings: Record<string, string> = {
      // More entertainment
      tv: 'üì∫',
      radio: 'üìª',
      camera: 'üì∑',
      video: 'üìπ',
      microphone: 'üé§',
      headphones: 'üéß',
      guitar: 'üé∏',
      piano: 'üéπ',
      drum: 'ü•Å',
      trumpet: 'üé∫',
      violin: 'üéª',
      saxophone: 'üé∑',

      // More symbols and objects
      fire: 'üî•',
      bomb: 'üí£',
      diamond: 'üíé',
      gem: 'üíé',
      ring: 'üíç',
      balloon: 'üéà',
      confetti: 'üéä',
      celebration: 'üéÜ',

      // More transport
      helicopter: 'üöÅ',
      rocket: 'üöÄ',
      satellite: 'üõ∞Ô∏è',
      ufo: 'üõ∏',
      ship: 'üö¢',
      anchor: '‚öì',
      sailboat: '‚õµ',
      'ferris-wheel': 'üé°',
      'roller-coaster': 'üé¢',
      carousel: 'üé†',
      circus: 'üé™',
      tent: '‚õ∫',

      // More nature and environment
      desert: 'üèúÔ∏è',
      volcano: 'üåã',
      island: 'üèùÔ∏è',
      beach: 'üèñÔ∏è',
      camping: 'üèïÔ∏è',
      'national-park': 'üèûÔ∏è',
      stadium: 'üèüÔ∏è',
      bridge: 'üåâ',
      cityscape: 'üèôÔ∏è',
      'night-sky': 'üåÉ',
      sunrise: 'üåÖ',
      sunset: 'üåá',

      // More technology and gadgets
      keyboard: '‚å®Ô∏è',
      'mouse-computer': 'üñ±Ô∏è',
      printer: 'üñ®Ô∏è',
      scanner: 'üì∏',
      cd: 'üíø',
      dvd: 'üìÄ',
      'floppy-disk': 'üíæ',
      'hard-disk': 'üíæ',
      battery: 'üîã',
      'electric-plug': 'üîå',
      'satellite-antenna': 'üì°',
      'radio-signal': 'üì°',

      // More business and office
      briefcase: 'üíº',
      'office-building': 'üè¢',
      factory: 'üè≠',
      warehouse: 'üè≠',
      bank: 'üè¶',
      hospital: 'üè•',
      school: 'üè´',
      university: 'üè´',
      library: 'üèõÔ∏è',
      museum: 'üèüÔ∏è',
      theater: 'üé≠',
      cinema: 'üé¨',

      // More household items
      bed: 'üõèÔ∏è',
      couch: 'üõãÔ∏è',
      chair: 'emoji-1f6c0',
      table: 'emoji-1f5d4',
      lamp: 'üí°',
      candle: 'üïØÔ∏è',
      mirror: 'ü™û',
      window: 'ü™ü',
      door: 'üö™',
      key: 'üîë',
      lock: 'üîí',
      unlock: 'üîì',

      // More clothing and accessories
      shirt: 'üëï',
      jeans: 'üëñ',
      dress: 'üëó',
      bikini: 'üëô',
      kimono: 'üëò',
      sari: 'ü•ª',
      'lab-coat': 'ü•º',
      goggles: 'ü•Ω',
      gloves: 'üß§',
      coat: 'üß•',
      socks: 'üß¶',
      hat: 'emoji-1f9e2',
      'top-hat': 'üé©',
      'military-helmet': 'ü™ñ',

      // More miscellaneous
      hourglass: '‚è≥',
      stopwatch: '‚è±Ô∏è',
      'alarm-clock': '‚è∞',
      timer: 'emoji-23f2',
      'magnifying-glass': 'üîç',
      microscope: 'üî¨',
      telescope: 'üî≠',
      compass: 'üß≠',
      globe: 'üåç',
      'world-map': 'üó∫Ô∏è',
      flag: 'üö©',
      pennant: 'emoji-1f3f1',
    };

    // Merge additional mappings
    const allMappings = { ...iconMap, ...additionalMappings };

    // Return mapped EmojiIcon ID or default if not found
    return allMappings[iconId.toLowerCase()] || 'üí°'; // Default to lightbulb
  }

  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  private createFallbackMap(nameMap: string, error: Error): string {
    return `<map name="${nameMap}" version="tango" layout="mindmap">
    <topic central="true" text="${nameMap}" id="1">
        <topic position="200,0" order="0" text="Import Error" shape="line" id="2">
            <note><![CDATA[XMind import failed: ${error.message}. Please check the file format and try again.]]></note>
        </topic>
    </topic>
</map>`;
  }
}

export default XMindImporter;
